import { ChromaClient, Collection } from 'chromadb'; // ChromaClient from chromadb package
import { CHROMA_URL } from '../config';
import { generateEmbeddings } from './llmService';

let client: ChromaClient | undefined;

function getClient(): ChromaClient {
  if (!client) {
    if (!CHROMA_URL) {
      throw new Error('CHROMA_URL is not set. Vector DB service cannot operate.');
    }
    try {
      client = new ChromaClient({ path: CHROMA_URL });
      console.log('ChromaDB client initialized successfully.');
    } catch (error: any) {
      console.error('Failed to initialize ChromaDB client:', error.message);
      throw new Error('Could not initialize ChromaDB client.');
    }
  }
  return client;
}

// The concept of a default embedder attached to the collection is removed.
// Instead, we will generate embeddings explicitly using our llmService
// before calling search functions.

export async function getOrCreateCollection(collectionName: string): Promise<Collection> {
  const chromaClient = getClient();
  try {
    // If using OpenAI embeddings generated by our llmService, we don't strictly need to pass an embedder to getOrCreateCollection
    // unless we want Chroma to handle embeddings for queryTexts automatically.
    // For adding pre-computed embeddings, no embeddingFunction is strictly needed at collection creation.
    // However, if we want `collection.query({ queryTexts: [...] })` to work, an embedder is useful.
    const collection = await chromaClient.getOrCreateCollection({
        name: collectionName,
        // embeddingFunction: openaiEmbedder // Optional: if we want queryTexts to be auto-embedded by Chroma
    });
    console.log(`Collection '${collectionName}' ensured.`);
    return collection;
  } catch (error: any) {
    console.error(`Error getting or creating collection '${collectionName}':`, error.message);
    throw error;
  }
}

export async function addOrUpdateChunks(
  collectionName: string,
  ids: string[],
  embeddings: number[][],
  documents: string[],
  metadatas: Record<string, any>[],
): Promise<void> {
  if (ids.length === 0) {
    console.log('No documents to add or update.');
    return;
  }
  try {
    const collection = await getOrCreateCollection(collectionName);
    // Chroma's add function also acts as an upsert if IDs already exist (behavior might vary by version)
    await collection.add({
      ids: ids,
      embeddings: embeddings,
      documents: documents,
      metadatas: metadatas,
    });
    console.log(`Successfully added/updated ${ids.length} documents in collection '${collectionName}'.`);
  } catch (error: any) {
    console.error(`Error adding/updating documents to collection '${collectionName}':`, error.message);
    throw error;
  }
}

export async function searchSimilarChunks(
  collectionName: string,
  queryEmbeddings: number[][], // Expect pre-computed embeddings for querying
  k: number = 5,
): Promise<any[][]> { // Returns an array of arrays of results (one array per query embedding)
  try {
    const collection = await getOrCreateCollection(collectionName);
    if (!queryEmbeddings || queryEmbeddings.length === 0) {
      return [];
    }
    const results = await collection.query({
      queryEmbeddings: queryEmbeddings,
      nResults: k,
      // include: ['metadatas', 'documents', 'distances'] // Specify what to include in results
    });
    // The structure of 'results' can be complex. Let's simplify it to return documents or metadatas.
    // For now, returning the raw 'results.documents' or similar based on what you need.
    // Example: results.documents, results.metadatas, results.ids, results.distances
    // Each of these is an array of arrays if multiple query embeddings were provided.
    console.log(`Search in '${collectionName}' found results for ${queryEmbeddings.length} queries.`);
    return results.documents ?? []; // Returning document texts by default
  } catch (error: any) {
    console.error(`Error searching in collection '${collectionName}':`, error.message);
    throw error;
  }
}

/**
 * Generates embeddings for a list of texts and then searches for similar chunks.
 * @param collectionName The name of the collection to search in.
 * @param queryTexts The texts to search for.
 * @param k The number of similar chunks to return.
 * @returns A promise that resolves to the search results.
 */
export async function searchSimilarChunksWithText(
  collectionName: string,
  queryTexts: string[],
  k: number = 5,
): Promise<any[][]> {
  if (!queryTexts || queryTexts.length === 0) {
    return [];
  }
  try {
    console.log(`Generating embeddings for ${queryTexts.length} query texts.`);
    const queryEmbeddings = await generateEmbeddings(queryTexts);
    console.log(`Searching for similar chunks with generated embeddings.`);
    return await searchSimilarChunks(collectionName, queryEmbeddings, k);
  } catch (error: any) {
    console.error(`Error generating embeddings or searching with text in collection '${collectionName}':`, error.message);
    throw error;
  }
}

// Exported for testing purposes only
export function _resetChromaClientForTesting() {
  client = undefined;
}
