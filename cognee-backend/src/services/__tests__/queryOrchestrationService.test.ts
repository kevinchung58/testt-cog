import { executeQueryAgainstGraph, searchVectorStore } from '../queryOrchestrationService';
import { generateCypherQuery, generateEmbeddings, synthesizeAnswerWithContext } from '../llmService';
import { executeQuery as executeNeo4jQuery } from '../neo4jService';
import { searchSimilarChunks as searchChroma } from '../vectorDbService';
import { CHROMA_COLLECTION_NAME } from '../../config';

// Mock services
jest.mock('../llmService');
jest.mock('../neo4jService');
jest.mock('../vectorDbService');
jest.mock('../../config', () => ({
  __esModule: true,
  CHROMA_COLLECTION_NAME: 'test_collection_name',
  // OPENAI_API_KEY: 'test-key' // Only if other services directly import it and it's not mocked elsewhere
}));

describe('Query Orchestration Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('executeQueryAgainstGraph', () => {
    it('should generate Cypher, execute query, and format results', async () => {
      const question = 'What is X?';
      const mockCypher = 'MATCH (n {name: "X"}) RETURN n';
      const mockNeo4jRawResult = {
        records: [{
          keys: ['n'],
          get: (key: string) => ({ labels: ['Entity'], properties: { name: 'X' } })
        }],
        summary: {}
      };
      const expectedFormattedResult = ["n: Node(labels: Entity, properties: {\"name\":\"X\"});"];

      (generateCypherQuery as jest.Mock).mockResolvedValue(mockCypher);
      (executeNeo4jQuery as jest.Mock).mockResolvedValue(mockNeo4jRawResult);

      const result = await executeQueryAgainstGraph(question);

      expect(generateCypherQuery).toHaveBeenCalledWith(question, expect.any(String));
      expect(executeNeo4jQuery).toHaveBeenCalledWith(mockCypher);
      expect(result).toEqual(expectedFormattedResult);
    });

    it('should return error message if Cypher generation returns placeholder/error', async () => {
      const question = 'Test question';
      (generateCypherQuery as jest.Mock).mockResolvedValue('// Error: LLM problem');
      const result = await executeQueryAgainstGraph(question);
      expect(result).toEqual(['Could not translate question to a graph query effectively. Query generated: // Error: LLM problem']);
      expect(executeNeo4jQuery).not.toHaveBeenCalled();
    });

    it('should handle errors from executeNeo4jQuery', async () => {
      const question = 'Test question';
      (generateCypherQuery as jest.Mock).mockResolvedValue('MATCH (n) RETURN n');
      (executeNeo4jQuery as jest.Mock).mockRejectedValue(new Error('Neo4j DB error'));
      const result = await executeQueryAgainstGraph(question);
      expect(result).toEqual(['An error occurred while querying the knowledge graph: Neo4j DB error']);
    });

    it('should handle Neo4j specific errors from executeNeo4jQuery', async () => {
        const question = 'Test question';
        const neo4jError = new Error('Invalid Cypher syntax');
        (neo4jError as any).code = 'Neo.ClientError.Statement.SyntaxError';
        (generateCypherQuery as jest.Mock).mockResolvedValue('MATCH (n RETURN n'); // Intentionally invalid
        (executeNeo4jQuery as jest.Mock).mockRejectedValue(neo4jError);
        const result = await executeQueryAgainstGraph(question);
        expect(result).toEqual(['Error executing graph query: Invalid Cypher syntax. Potentially invalid Cypher generated by LLM.']);
    });
  });

  describe('searchVectorStore', () => {
    it('should generate embedding, search Chroma, and format results', async () => {
      const question = 'Find similar documents to Y.';
      const mockEmbedding = [[0.1, 0.2]];
      const mockChromaResult = [['Document Y content']]; // searchChroma returns string[][]

      (generateEmbeddings as jest.Mock).mockResolvedValue(mockEmbedding);
      (searchChroma as jest.Mock).mockResolvedValue(mockChromaResult);

      const result = await searchVectorStore(question);

      expect(generateEmbeddings).toHaveBeenCalledWith([question]);
      expect(searchChroma).toHaveBeenCalledWith('test_collection_name', mockEmbedding, 3);
      expect(result).toEqual(mockChromaResult[0]); // Expecting the first (and only) list of documents
    });

    it('should return error message if embedding generation fails (all zeros)', async () => {
      const question = 'Test question';
      (generateEmbeddings as jest.Mock).mockResolvedValue([[0,0,0]]); // Mocking all zeros embedding
      const result = await searchVectorStore(question);
      expect(result).toEqual(['Could not generate a valid question embedding for vector search (possibly missing API key for embeddings).']);
      expect(searchChroma).not.toHaveBeenCalled();
    });

    it('should return error message if embedding generation returns empty array', async () => {
        const question = 'Test question';
        (generateEmbeddings as jest.Mock).mockResolvedValue([]); // Mocking empty result
        const result = await searchVectorStore(question);
        // This specific message comes from the check `if (questionEmbedding.length === 0)`
        expect(result).toEqual(['Failed to generate embedding for vector search.']);
        expect(searchChroma).not.toHaveBeenCalled();
    });

    it('should handle errors from searchChroma', async () => {
      const question = 'Test question';
      (generateEmbeddings as jest.Mock).mockResolvedValue([[0.1, 0.2]]);
      (searchChroma as jest.Mock).mockRejectedValue(new Error('Chroma DB error'));
      const result = await searchVectorStore(question);
      expect(result).toEqual(['An error occurred while searching the vector store: Chroma DB error']);
    });
  });
});
